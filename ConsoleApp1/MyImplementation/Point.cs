namespace DualEcPRNGDemo.MyImplementation
{
    public class Point
    {
        public BigInteger X;
        public BigInteger Y;
        public readonly Curve Curve;

        public bool IsInfinite => X is null && Y is null;

        public Point(BigInteger x, BigInteger y, Curve curve)
        {
            X = x;
            Y = y;
            Curve = curve;
        }

        public Point Negate()
        {
            var point = new Point(X, Y.Negate(), Curve);
            point.IsOnCurve();
            return point;
        }

        private static Point Add(Point leftOperand, Point rightOperand)
        {
            if (leftOperand.IsInfinite) return rightOperand;
            if (rightOperand.IsInfinite) return leftOperand;

            var curve = leftOperand.Curve;
            var lambda = GetLambdaForAddition(leftOperand, rightOperand)%curve.Prime;
            var newX = (lambda ^ 2) - leftOperand.X - rightOperand.X;
            newX = newX % curve.Prime;
            var newY = lambda * (leftOperand.X - newX) - leftOperand.Y;

            newY = newY % curve.Prime;

            var newPoint = new Point(newX, newY, curve);
            newPoint.IsOnCurve();
            return newPoint;
        }

        private Point Double()
        {
            if (IsInfinite) return this;

            var lambda = GetLambdaForDoubling()%Curve.Prime;
            var newX = (lambda ^ 2) - X*2;
            newX = newX % Curve.Prime;
            var newY = (lambda * (X - newX)) - Y;

            newY = newY % Curve.Prime;

            var newPoint = new Point(newX, newY, Curve);
            newPoint.IsOnCurve();
            return newPoint;
        }

        private static Point MultiplyByScalar(Point point, BigInteger scalar)
        {
            var result = new Point(null, null, point.Curve);

            while (scalar != 0)
            {
                if (scalar % 2 == 1)
                {
                    result = result + point;
                    scalar--;
                }
                else
                {
                    point = point.Double();
                    scalar = scalar / 2;
                }
            }

            return result;
        }

        private static BigInteger GetLambdaForAddition(Point leftOperand, Point rightOperand)
        {
            return (rightOperand.Y - leftOperand.Y) * (rightOperand.X - leftOperand.X).ModInverse(rightOperand.Curve.Prime);
        }

        private BigInteger GetLambdaForDoubling()
        {
            return (3*(X^2) + Curve.A) * (Y*2).ModInverse(Curve.Prime);
        }

        public static Point operator +(Point leftOperand, Point rightOperand)
        {
            return Add(leftOperand, rightOperand);
        }

        public static Point operator *(Point leftOperand, BigInteger scalar)
        {
            return MultiplyByScalar(leftOperand, scalar);
        }

        public static Point operator *(BigInteger scalar, Point leftOperand)
        {
            return MultiplyByScalar(leftOperand, scalar);
        }

        public void IsOnCurve()
        {
            Curve.IsPointOnCurve(this);
        }

        public override string ToString()
        {
            if (X is null && Y is null)
                return "(None, None)";
            return $"({X}, {Y})";
        }
    }
}
