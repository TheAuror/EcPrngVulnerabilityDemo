using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

namespace DualEcPRNGDemo.MyImplementation
{
    public class BigInteger
    {
        private readonly System.Numerics.BigInteger _value;
        public Lazy<byte[]> AsByteArray => new Lazy<byte[]>(() => _value.ToByteArray());
        public bool IsEven => _value.IsEven;

        #region Contructors

        public BigInteger(System.Numerics.BigInteger value)
        {
            _value = value;
        }

        public BigInteger(string value, bool isHex = false)
        {
            _value = isHex ?
                System.Numerics.BigInteger.Parse(value, NumberStyles.AllowHexSpecifier) :
                System.Numerics.BigInteger.Parse(value, NumberStyles.AllowLeadingWhite);
        }

        public BigInteger(double value)
        {
            _value = new System.Numerics.BigInteger(value);
        }

        public BigInteger(IEnumerable<byte> bytes)
        {
            _value = new System.Numerics.BigInteger(bytes.ToArray());
        }

        #endregion

        #region Operator overrides

        public static BigInteger operator +(BigInteger leftOperand, BigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new BigInteger(System.Numerics.BigInteger.Add(leftOperand, rightOperand));
        }

        public static BigInteger operator -(BigInteger leftOperand, BigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new BigInteger(System.Numerics.BigInteger.Subtract(leftOperand, rightOperand));
        }

        public static BigInteger operator *(BigInteger leftOperand, BigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new BigInteger(System.Numerics.BigInteger.Multiply(leftOperand, rightOperand));
        }

        public static BigInteger operator /(BigInteger leftOperand, BigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new BigInteger(System.Numerics.BigInteger.Divide(leftOperand, rightOperand));
        }

        public static BigInteger operator %(BigInteger leftOperand, BigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);

            System.Numerics.BigInteger.DivRem(leftOperand, rightOperand, out System.Numerics.BigInteger result);

            return result.Sign == -1 ? 
                new BigInteger(System.Numerics.BigInteger.Add(result, rightOperand)) : 
                new BigInteger(result);
        }

        public static BigInteger operator ^(BigInteger leftOperand, int rightOperand)
        {
            if (leftOperand is null)
                throw new ArgumentNullException();
            return new BigInteger(System.Numerics.BigInteger.Pow(leftOperand, rightOperand));
        }

        public static BigInteger operator ^(BigInteger leftOperand, BigInteger rightOperand)
        {
            if (leftOperand is null)
                throw new ArgumentNullException();
            return new BigInteger(System.Numerics.BigInteger.Pow(leftOperand, (int)rightOperand._value));
        }

        public static bool operator ==(BigInteger leftOperand, BigInteger rightOperand)
        {
            if (rightOperand is null && leftOperand is null) return true;

            return rightOperand != null && leftOperand != null && leftOperand._value.Equals(rightOperand._value);
        }

        public static bool operator !=(BigInteger leftOperand, BigInteger rightOperand)
        {
            return !(leftOperand == rightOperand);
        }

        public static bool operator <(BigInteger leftOperand, BigInteger rightOperand)
        {
            return leftOperand._value < rightOperand._value;
        }

        public static bool operator >(BigInteger leftOperand, BigInteger rightOperand)
        {
            return leftOperand._value > rightOperand._value;
        }

        public static BigInteger operator ++(BigInteger operand)
        {
            ArgumentNullGuard(operand);
            return new BigInteger(operand + 1);
        }

        public static BigInteger operator --(BigInteger operand)
        {
            ArgumentNullGuard(operand);
            return new BigInteger(operand - 1);
        }

        #endregion

        #region Implicit operators

        public static implicit operator BigInteger(double d)
        {
            return new BigInteger(d);
        }

        public static implicit operator System.Numerics.BigInteger(BigInteger a)
        {
            return a._value;
        }

        #endregion

        #region Arithmetics

        public BigInteger ModPow(BigInteger exponant, BigInteger modulus)
        {
            return exponant == -1 ? 
                ModInverse(modulus) : 
                new BigInteger(System.Numerics.BigInteger.ModPow(_value, exponant, modulus));
        }

        public BigInteger Negate()
        {
            return new BigInteger(System.Numerics.BigInteger.Negate(this));
        }

        public BigInteger ModInverse(BigInteger modulo)
        {
            var value = _value;
            if (_value.Sign == -1)
                value = System.Numerics.BigInteger.Add(_value, modulo);

            return value == System.Numerics.BigInteger.Zero ? 
                new BigInteger(System.Numerics.BigInteger.Zero) : 
                new BigInteger(System.Numerics.BigInteger.ModPow(value, modulo - 2, modulo));
        }

        public static BigInteger GratestCommonDivisor(BigInteger leftOperand, BigInteger rightOperand)
        {
            while (true)
            {
                if (rightOperand == 0) return leftOperand;
                var temp = leftOperand;
                leftOperand = rightOperand;
                rightOperand = temp % rightOperand;
            }
        }

        public List<BigInteger> ModSqrt(BigInteger modulus)
        {
            if (modulus is null || modulus == 0 || modulus._value.Sign == -1) return null;

            var result = new List<BigInteger>();

            //If the indicators value is "modulus - 1" then there is no modular square root
            var indicator = ModPow((modulus - 1) / 2, modulus);
            if (indicator == modulus - 1) return result;

            //Special case for faster solution
            if (modulus % 4 == 3)
            {
                var exponant = (modulus + 1) / 4;
                var firstResult = ModPow(exponant, modulus);

                if (firstResult * firstResult % modulus == this)
                {
                    result.Add(firstResult);
                    result.Add(firstResult.Negate());
                }

                return result;
            }

            var q = modulus - 1;
            BigInteger s = 0;

            while (q.IsEven)
            {
                q = q / 2;
                s++;
            }

            BigInteger z = 1;

            while (z.ModPow((modulus-1)/2, modulus) != modulus-1)
            {
                z++;
            }

            var m = s;
            var c = z.ModPow(q, modulus);
            var t = ModPow(q, modulus);
            var r = ModPow((q + 1) / 2, modulus);

            while (true)
            {
                if (t == 0) return result;
                if (t == 1)
                {
                    if (r * r % modulus != this) return result;

                    result.Add(r);
                    result.Add(r.Negate());

                    return result;
                }

                BigInteger i = 1;
                while (t.ModPow(Constants.Two^i, modulus) != 1 && i < m-1)
                {
                    i++;
                }

                var b = c.ModPow(Constants.Two.ModPow(m - i - 1, modulus), modulus);
                m = i;
                c = b.ModPow(Constants.Two, modulus);
                t = t * c % modulus;
                r = r * b % modulus;
            }
        }

        #endregion

        #region Basic class overrides

        public override bool Equals(object obj)
        {
            if (null == obj) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((BigInteger)obj);
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public override string ToString()
        {
            return $"({_value})";
        }

        public BigInteger Clone()
        {
            var newValue = _value + 1;
            newValue--;
            return new BigInteger(newValue);
        }

        #endregion

        private static void ArgumentNullGuard(BigInteger operand)
        {
            if (operand is null) throw new ArgumentNullException(nameof(operand));
        }

        private static void ArgumentNullGuard(BigInteger leftOperand, BigInteger rightOperand)
        {
            if (leftOperand is null) throw new ArgumentNullException(nameof(leftOperand));
            if (rightOperand is null) throw new ArgumentNullException(nameof(rightOperand));
        }
    }
}