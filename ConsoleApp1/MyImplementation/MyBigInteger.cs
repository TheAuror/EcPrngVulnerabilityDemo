using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Numerics;

namespace DualEcPRNGDemo.MyImplementation
{
    public class MyBigInteger
    {
        private readonly BigInteger _value;
        public Lazy<byte[]> AsByteArray => new Lazy<byte[]>(() => _value.ToByteArray());
        public bool IsEven => _value.IsEven;

        #region Contructors

        public MyBigInteger(BigInteger value)
        {
            _value = value;
        }

        public MyBigInteger(string value, bool isHex = false)
        {
            _value = isHex ? 
                BigInteger.Parse(value, NumberStyles.AllowHexSpecifier) : 
                BigInteger.Parse(value, NumberStyles.AllowLeadingWhite);
        }

        public MyBigInteger(double value)
        {
            _value = new BigInteger(value);
        }

        public MyBigInteger(IEnumerable<byte> bytes)
        {
            _value = new BigInteger(bytes.ToArray());
        }

        #endregion

        #region Operator overrides

        public static MyBigInteger operator +(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new MyBigInteger(BigInteger.Add(leftOperand, rightOperand));
        }

        public static MyBigInteger operator -(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new MyBigInteger(BigInteger.Subtract(leftOperand, rightOperand));
        }

        public static MyBigInteger operator *(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new MyBigInteger(BigInteger.Multiply(leftOperand, rightOperand));
        }

        public static MyBigInteger operator /(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new MyBigInteger(BigInteger.Divide(leftOperand, rightOperand));
        }

        public static MyBigInteger operator %(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);

            BigInteger.DivRem(leftOperand, rightOperand, out BigInteger result);

            return result.Sign == -1 ? 
                new MyBigInteger(BigInteger.Add(result, rightOperand)) : 
                new MyBigInteger(result);
        }

        public static MyBigInteger operator ^(MyBigInteger leftOperand, int rightOperand)
        {
            if (leftOperand is null)
                throw new ArgumentNullException();
            return new MyBigInteger(BigInteger.Pow(leftOperand, rightOperand));
        }

        public static MyBigInteger operator ^(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            if (leftOperand is null)
                throw new ArgumentNullException();
            return new MyBigInteger(BigInteger.Pow(leftOperand, (int)rightOperand._value));
        }

        public static bool operator ==(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            if (rightOperand is null && leftOperand is null) return true;

            return rightOperand != null && leftOperand != null && leftOperand._value.Equals(rightOperand._value);
        }

        public static bool operator !=(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            return !(leftOperand == rightOperand);
        }

        public static bool operator <(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            return leftOperand._value < rightOperand._value;
        }

        public static bool operator >(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            return leftOperand._value > rightOperand._value;
        }

        public static MyBigInteger operator ++(MyBigInteger operand)
        {
            ArgumentNullGuard(operand);
            return new MyBigInteger(operand + 1);
        }

        public static MyBigInteger operator --(MyBigInteger operand)
        {
            ArgumentNullGuard(operand);
            return new MyBigInteger(operand - 1);
        }

        #endregion

        #region Implicit operators

        public static implicit operator MyBigInteger(double d)
        {
            return new MyBigInteger(d);
        }

        public static implicit operator BigInteger(MyBigInteger a)
        {
            return a._value;
        }

        #endregion

        #region Arithmetics

        public MyBigInteger ModPow(MyBigInteger exponant, MyBigInteger modulus)
        {
            return exponant == -1 ? 
                ModInverse(modulus) : 
                new MyBigInteger(BigInteger.ModPow(_value, exponant, modulus));
        }

        public MyBigInteger Negate()
        {
            return new MyBigInteger(BigInteger.Negate(this));
        }

        public MyBigInteger ModInverse(MyBigInteger modulo)
        {
            var value = _value;
            if (_value.Sign == -1)
                value = BigInteger.Add(_value, modulo);

            return value == BigInteger.Zero ? 
                new MyBigInteger(BigInteger.Zero) : 
                new MyBigInteger(BigInteger.ModPow(value, modulo - 2, modulo));
        }

        public static MyBigInteger GratestCommonDivisor(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            while (true)
            {
                if (rightOperand == 0) return leftOperand;
                var temp = leftOperand;
                leftOperand = rightOperand;
                rightOperand = temp % rightOperand;
            }
        }

        public List<MyBigInteger> ModSqrt(MyBigInteger modulus)
        {
            if (modulus is null || modulus == 0 || modulus._value.Sign == -1) return null;

            var result = new List<MyBigInteger>();

            //If the indicators value is "modulus - 1" then there is no modular square root
            var indicator = ModPow((modulus - 1) / 2, modulus);
            if (indicator == modulus - 1) return result;

            //Special case for faster solution
            if (modulus % 4 == 3)
            {
                var exponant = (modulus + 1) / 4;
                var firstResult = ModPow(exponant, modulus);

                if (firstResult * firstResult % modulus == this)
                {
                    result.Add(firstResult);
                    result.Add(firstResult.Negate());
                }

                return result;
            }

            var q = modulus - 1;
            MyBigInteger s = 0;

            while (q.IsEven)
            {
                q = q / 2;
                s++;
            }

            MyBigInteger z = 1;

            while (z.ModPow((modulus-1)/2, modulus) != modulus-1)
            {
                z++;
            }

            var m = s;
            var c = z.ModPow(q, modulus);
            var t = ModPow(q, modulus);
            var r = ModPow((q + 1) / 2, modulus);

            while (true)
            {
                if (t == 0) return result;
                if (t == 1)
                {
                    if (r * r % modulus != this) return result;

                    result.Add(r);
                    result.Add(r.Negate());

                    return result;
                }

                MyBigInteger i = 1;
                while (t.ModPow(MyConstants.Two^i, modulus) != 1 && i < m-1)
                {
                    i++;
                }

                var b = c.ModPow(MyConstants.Two.ModPow(m - i - 1, modulus), modulus);
                m = i;
                c = b.ModPow(MyConstants.Two, modulus);
                t = t * c % modulus;
                r = r * b % modulus;
            }
        }

        #endregion

        #region Basic class overrides

        public override bool Equals(object obj)
        {
            if (null == obj) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((MyBigInteger)obj);
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public override string ToString()
        {
            return $"({_value})";
        }

        public MyBigInteger Clone()
        {
            var newValue = _value + 1;
            newValue--;
            return new MyBigInteger(newValue);
        }

        #endregion

        private static void ArgumentNullGuard(MyBigInteger operand)
        {
            if (operand is null) throw new ArgumentNullException(nameof(operand));
        }

        private static void ArgumentNullGuard(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            if (leftOperand is null) throw new ArgumentNullException(nameof(leftOperand));
            if (rightOperand is null) throw new ArgumentNullException(nameof(rightOperand));
        }
    }
}