using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Numerics;

namespace ConsoleApp1.MyImplementation
{
    public class MyBigInteger
    {
        private readonly BigInteger _value;
        public Lazy<byte[]> AsByteArray => new Lazy<byte[]>(() => _value.ToByteArray());
        public bool IsEven => _value.IsEven;

        #region Contructors

        public MyBigInteger(BigInteger value)
        {
            _value = value;
        }

        public MyBigInteger(string value, bool isHex = false)
        {
            _value = isHex ? 
                BigInteger.Parse(value, NumberStyles.AllowHexSpecifier) : 
                BigInteger.Parse(value, NumberStyles.AllowLeadingWhite);
        }

        public MyBigInteger(double value)
        {
            _value = new BigInteger(value);
        }

        public MyBigInteger(IEnumerable<byte> bytes)
        {
            _value = new BigInteger(bytes.ToArray());
        }

        #endregion

        #region Operator overrides

        public static MyBigInteger operator +(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new MyBigInteger(BigInteger.Add(leftOperand, rightOperand));
        }

        public static MyBigInteger operator -(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new MyBigInteger(BigInteger.Subtract(leftOperand, rightOperand));
        }

        public static MyBigInteger operator *(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new MyBigInteger(BigInteger.Multiply(leftOperand, rightOperand));
        }

        public static MyBigInteger operator /(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);
            return new MyBigInteger(BigInteger.Divide(leftOperand, rightOperand));
        }

        public static MyBigInteger operator %(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            ArgumentNullGuard(leftOperand, rightOperand);

            BigInteger.DivRem(leftOperand, rightOperand, out BigInteger result);

            return result.Sign == -1 ? 
                new MyBigInteger(BigInteger.Add(result, rightOperand)) : 
                new MyBigInteger(result);
        }

        public static MyBigInteger operator ^(MyBigInteger leftOperand, int rightOperand)
        {
            if (leftOperand is null)
                throw new ArgumentNullException();
            return new MyBigInteger(BigInteger.Pow(leftOperand, rightOperand));
        }

        public static MyBigInteger operator ^(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            if (leftOperand is null)
                throw new ArgumentNullException();
            return new MyBigInteger(BigInteger.Pow(leftOperand, (int)rightOperand._value));
        }

        public static bool operator ==(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            if (rightOperand is null && leftOperand is null) return true;

            return rightOperand != null && leftOperand != null && leftOperand._value.Equals(rightOperand._value);
        }

        public static bool operator !=(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            return !(leftOperand == rightOperand);
        }

        public static bool operator <(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            return leftOperand._value < rightOperand._value;
        }

        public static bool operator >(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            return leftOperand._value > rightOperand._value;
        }

        public static MyBigInteger operator ++(MyBigInteger operand)
        {
            ArgumentNullGuard(operand);
            return new MyBigInteger(operand + 1);
        }

        public static MyBigInteger operator --(MyBigInteger operand)
        {
            ArgumentNullGuard(operand);
            return new MyBigInteger(operand - 1);
        }

        #endregion

        #region Implicit operators

        public static implicit operator MyBigInteger(double d)
        {
            return new MyBigInteger(d);
        }

        public static implicit operator BigInteger(MyBigInteger a)
        {
            return a._value;
        }

        #endregion

        #region Arithmetics

        public MyBigInteger ModPow(MyBigInteger exponant, MyBigInteger modulus)
        {
            return exponant == -1 ? 
                ModInverse(modulus) : 
                new MyBigInteger(BigInteger.ModPow(_value, exponant, modulus));
        }

        public MyBigInteger Negate()
        {
            return new MyBigInteger(BigInteger.Negate(this));
        }

        public MyBigInteger ModInverse(MyBigInteger modulo)
        {
            var value = _value;
            if (_value.Sign == -1)
                value = BigInteger.Add(_value, modulo);

            return value == BigInteger.Zero ? 
                new MyBigInteger(BigInteger.Zero) : 
                new MyBigInteger(BigInteger.ModPow(value, modulo - 2, modulo));
        }

        public static MyBigInteger GratestCommonDivisor(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            while (true)
            {
                if (rightOperand == 0) return leftOperand;
                var temp = leftOperand;
                leftOperand = rightOperand;
                rightOperand = temp % rightOperand;
            }
        }

        public List<MyBigInteger> ModSqrt(MyBigInteger modulus)
        {
            if (modulus is null || modulus == 0 || modulus._value.Sign == -1) return null;

            var result = new List<MyBigInteger>();

            //If the indicators value is "modulus - 1" then there is no modular square root
            var indicator = ModPow((modulus - 1) / 2, modulus);
            if (indicator == modulus - 1) return result;

            //Special case for faster solution
            if (modulus % 4 == 3)
            {
                var exponant = (modulus + 1) / 4;
                var firstResult = ModPow(exponant, modulus);
                var secondResult = firstResult - modulus;

                if (firstResult * firstResult % modulus == this)
                {
                    result.Add(firstResult);
                    result.Add(firstResult.Negate());
                }

                if (secondResult * secondResult % modulus == this)
                {
                    result.Add(secondResult);
                    result.Add(secondResult.Negate());
                }

                return result;
            }

            var nQ = modulus - 1;
            MyBigInteger nS = 0;

            while (nQ.IsEven)
            {
                nQ = nQ / 2;
                nS++;
            }

            MyBigInteger nZ = 1;

            while (nZ.ModPow((modulus-1)/2, modulus) != modulus-1)
            {
                nZ++;
            }

            var nM = nS;
            var nC = nZ.ModPow(nQ, modulus);
            var nT = ModPow(nQ, modulus);
            var nR = ModPow((nQ + 1) / 2, modulus);

            while (true)
            {
                if (nT == 0) return result;
                if (nT == 1)
                {
                    if (nR * nR % modulus == this)
                    {
                        result.Add(nR);
                        result.Add(nR.Negate());
                    }

                    nR = nR - modulus;
                    if (nR * nR % modulus == this)
                    {
                        result.Add(nR);
                        result.Add(nR.Negate());
                    }
                    return result;
                }

                MyBigInteger i = 1;
                while (nT.ModPow(MyConstants.Two^i, modulus) != 1 && i < nM-1)
                {
                    i++;
                }

                var nB = nC.ModPow(MyConstants.Two.ModPow(nM - i - 1, modulus), modulus);
                nM = i;
                nC = nB.ModPow(MyConstants.Two, modulus);
                nT = nT * nC % modulus;
                nR = nR * nB % modulus;
            }
        }

        #endregion

        #region Basic class overrides

        public override bool Equals(object obj)
        {
            if (null == obj) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((MyBigInteger)obj);
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public override string ToString()
        {
            return $"({_value})";
        }

        public MyBigInteger Clone()
        {
            var newValue = _value + 1;
            newValue--;
            return new MyBigInteger(newValue);
        }

        #endregion

        private static void ArgumentNullGuard(MyBigInteger operand)
        {
            if (operand is null) throw new ArgumentNullException(nameof(operand));
        }

        private static void ArgumentNullGuard(MyBigInteger leftOperand, MyBigInteger rightOperand)
        {
            if (leftOperand is null) throw new ArgumentNullException(nameof(leftOperand));
            if (rightOperand is null) throw new ArgumentNullException(nameof(rightOperand));
        }
    }
}