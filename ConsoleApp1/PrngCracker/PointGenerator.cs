using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using DualEcPRNGDemo.MyImplementation;

namespace DualEcPRNGDemo.PrngCracker
{
    public class PointGenerator
    {
        private const int WorkerCount = 1;
        private const int GeneratedPointBatchPerWorker = 1;
        private const int ProgressReportPrecision = 10;

        private int _pointGenerationProgress = -1;

        private readonly ConcurrentBag<WorkerProgressModel> _workerProgress = new ConcurrentBag<WorkerProgressModel>();

        private readonly Curve _curve;
        private readonly BigInteger _randomValue;

        private readonly ConcurrentQueue<List<Point>> _generatedPointBatches = new ConcurrentQueue<List<Point>>();

        public PointGenerator(Curve curve, BigInteger randomValue)
        {
            _curve = curve;
            _randomValue = randomValue;
        }

        public ConcurrentQueue<List<Point>> GeneratePoints()
        {
            GeneratePossiblePoints();
            return _generatedPointBatches;
        }

        private void GeneratePossiblePoints()
        {
            Parallel.ForEach(Enumerable.Range(0, WorkerCount).ToList(), e =>
            {
                var worker = CreateGeneratorWorker();
                for (var i = 0; i < GeneratedPointBatchPerWorker; i++)
                {
                    if (worker.IsBusy)
                    {
                        Thread.Sleep(10);
                        i--;
                    }
                    else
                    {
                        worker.RunWorkerAsync(e * WorkerCount + i);
                    }
                }
            });
        }

        #region BackgroundWorker Functions

        private BackgroundWorker CreateGeneratorWorker()
        {
            var worker = new BackgroundWorker { WorkerReportsProgress = true };

            worker.DoWork += GeneratePointsInRange;
            worker.ProgressChanged += OnProgressChanged;
            worker.RunWorkerCompleted += WorkerOnRunWorkerCompleted;
            return worker;
        }

        private void OnProgressChanged(object sender, ProgressChangedEventArgs args)
        {
            var currentWorkerProgress = GetProgressModelForCurrentWorker(sender.GetHashCode());

            currentWorkerProgress.CurrentProgress = args.ProgressPercentage;

            var progress = _workerProgress.Sum(model =>
            {
                var relativeProgress = model.CompletedBatches / ((double)GeneratedPointBatchPerWorker * WorkerCount) * 100;
                relativeProgress += model.CurrentProgress / ((double)GeneratedPointBatchPerWorker * WorkerCount);
                return relativeProgress;
            });

            if (_pointGenerationProgress >= progress - progress % ProgressReportPrecision) return;

            _pointGenerationProgress = (int)(progress - progress % ProgressReportPrecision);

            Console.WriteLine($"Point generation progress: {_pointGenerationProgress}%");
        }

        private void WorkerOnRunWorkerCompleted(object sender, RunWorkerCompletedEventArgs args)
        {
            _generatedPointBatches.Enqueue((List<Point>)args.Result);

            var worker = (BackgroundWorker)sender;
            var progress = GetProgressModelForCurrentWorker(worker.GetHashCode());
            if (progress.CompletedBatches + 1 < GeneratedPointBatchPerWorker)
                progress.CompletedBatches++;
        }

        #endregion

        private void GeneratePointsInRange(object sender, DoWorkEventArgs args)
        {
            var worker = (BackgroundWorker) sender;
            var newPoints = new List<Point>();
            var index = (int)args.Argument;
            var batchSize = (int)(Math.Pow(2, Constants.P256.CutBits) / (WorkerCount * GeneratedPointBatchPerWorker));
            var min = index * batchSize;
            var max = (index + 1) * batchSize;

            for (var i = min; i < max; i++)
            {
                var bytes = _randomValue.AsByteArray.Value;
                var significantBits = BitConverter.GetBytes(i).Take(Constants.P256.CutBytes);
                var possibleX = new BigInteger(bytes.Concat(significantBits));

                newPoints.AddRange(_curve.GetPointsAt(possibleX));

                double count = i - min + 1;
                if (Math.Abs(count % ProgressReportPrecision) < 1 || i == max-1)
                {
                    var percentProgress = (int)(count / (max - min) * 100f);
                    worker.ReportProgress(percentProgress);
                }
            }

            args.Result = newPoints;
        }
        
        private WorkerProgressModel GetProgressModelForCurrentWorker(int workerHash)
        {
            if (_workerProgress.All(e => e.WorkedId != workerHash))
                _workerProgress.Add(new WorkerProgressModel
                {
                    WorkedId = workerHash,
                    CompletedBatches = 0,
                    CurrentProgress = 0
                });

            return _workerProgress.First(e => e.WorkedId == workerHash);
        }
    }
}